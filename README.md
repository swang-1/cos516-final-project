# Counterexample-guided Invariant Search using Syntax Guided Synthesis for Veil & Ivy

## How to Use

### Lean Examples

To run the Lean protocol examples in veil, run `lake build` in the `Lean` directory. The example protocols can be found in `Lean/VeilProtocols`.

### Invariant Generation and Search

The proof of concept (PoC) for the invariant generation and search algorithm are implemented in Python using the Z3 API. The required packages are Z3 and `tqdm`, which can be installed using pip:
```
pip install z3-solver
pip install tqdm
```
To run Python tests, uncomment the desired tests in `PoC/test.py` and run the file as a script:
```
python3 PoC/test.py
```
To run the invariant generation and search for the examples, run any of the files in `PoC/Examples`:
```
python3 PoC/Examples/Ring.py
python3 PoC/DecentralizedLock.py
python3 PoC/TwoPhaseCommit.py
```

## File Description

### Veil Examples

The invariant search algorithm is evaluated on three example protocols: the ring leader election protocol, the two phase commit protocol, and a decentralized locking protocol. The Veil implementations of these protocols are found in `Lean/VeilProtocols`. These implementations are adapted from the original Veil repository, which can be found at: https://github.com/verse-lab/veil/tree/main?tab=readme-ov-file.

Each of these files contains (1) the protocol implementation, (2) a safety property to prove, (3) the original invariants used to prove this property, (4) the invariants generated by the search algorithm, and (5) the command `#check_invariants`, which is used to verify the inductiveness of the safety property and invariants. For example, `/Lean/VeilProtocols/Ring.lean` looks like:
```
-- Implementation (omitted for brevity)
...

-- Safety property
safety [single_leader] leader L → le N L

-- ====== The invariants for the original example ======
-- invariant pending S D ∧ btw S N D → le N S
-- invariant pending L L → le N L

-- ====== Invariants from running search ======
invariant btw W Y X ∧ pending Y W → ¬ le Y X
invariant btw W Y X ∧ pending X X → ¬ le X Y
invariant btw W Y X ∧ pending W W → ¬ le W Y
invariant ¬ le W X ∧ ¬ le Y X → ¬ pending X X

#gen_spec

set_option veil.printCounterexamples true
set_option veil.smt.model.minimize true
set_option veil.vc_gen "transition"

#check_invariants
```

### Invariant Generation and Search

The invariant generation and search algorithms are implemented using the Python Z3 API and can be found in `PoC/InvariantSearch.py`:
```
def invariant_search(axioms, init, trs, cand_set, cex, debug=False):
    '''
    Performs invariant search over a provided set of candidate invariants to
    find a set of inductive invariants that eliminates the given counterexample.
    The inductiveness check is performed against provided initialization and
    transition constraints, as well as any additional axioms.

    Input:
        axioms: A list of Z3 constraints representing the axioms for the 
            system specification
        init: A list of Z3 constraints representing the initial conditions
            for the system specification
        tr: A list of Z3 constraints representing the transition relations
            for the system specification
        cand_set: A list of Invariant objects to be searched over
        cex: A list of Z3 constraints describing the counterexample to
            eliminate
        debug: Set debug mode, which prints additional information
    Output:
        learned: A list of Invariant objects representing a conjunction of relatively
            inductive invariants from `cand_set` that eliminate `cex`, if such
            a conjunction exists. Returns None otherwise.
        success: A boolean that indicates whether the invariant search succeeded in
            eliminating the counterexample
    '''
    ...

    def generate_invariants(qvars, relations, max_depth=2, max_depth_rhs=None):
    '''
    Generates all invariants of the form

        Forall x, y, ... . LHS(x, y, ...) ==> RHS(x, y, ...)
    
    where LHS is a conjunction of predicates and RHS is a conjunction
    or disjunction of predicates, and LHS and RHS each contain at most
    `max_depth` predicates. The quantified variables are supplied by the
    argument `qvars`. The set of all possible predicates includes
    `relations` and equality relations over the sorts given by `sorts`.

    Inputs:
        qvars: A list of unique Z3 constants representing universally
            quantified variables that can appear in formulas
        sorts: A list of Z3 sorts that appear in relations 
        relations: A list of Relation objects (see lib.py) representing
            the possible relations that can appear as predicates
        max_depth: The maximum number of predicates that can appear in
            a conjunct/disjunct of any invariant
        max_depth_rhs: Optional argument for defining different max depths
            for the lhs and rhs of invariants. If this parameter is included,
            then max_depth will be the max_depth of the LHS.
    Output:
        A list of Invariant objects
    '''
```

`PoC/lib.py` contains classes that define the intermediate representation for invariants, predicates, etc. that are used by the two algorithms above. For example, the application of a predicate to some quantified variables is represented by the `App` class, which stores a relation `r` and the arguments `x1, x2, ...` to be passed. The class then contains a method for instantiating the Z3 term `r(x1, x2, ...)`. The conjunctions and disjunctions found in the LHS and RHS of invariants are then represented by lists of `App` objects, stored in the `Invariant` class. For conjunctions, the empty list represents `True`, while for disjunctions, it represents `False`

`PoC/test.py` contains tests used for validating the invariant generation and search algorithms, as well as some of the protocl implementations and counterexamples. These tests can be run by uncommenting the lines at the bottom of the file.

`/PoC/Examples` contains the protocol examples described above, translated to Z3 formulas. In addition to the core implementation (types, relations, initialization, transition), each of these files describes the relevant counterexample(s) and packages the implementation into the intermediate representation from `lib.py` for calling the invariant generation and search. Running each of these files as a script will cause the found invariants to be written to a `.csv` file.